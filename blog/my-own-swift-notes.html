<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>School assignment</title>
    <link rel="stylesheet" href="../css/style.css" />
    <!-- particles.js lib - https://github.com/VincentGarreau/particles.js -->
    <script src="http://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script src="../js/particles.js"></script>
    <script defer src="../js/particles.js"></script>
</head>

<body onload="setActive()">
    <script>
        const setActive = () => {
            const navlinks = Array.prototype.slice.apply(document.getElementsByClassName('navlink'));
            navlinks.forEach(element => { //loop through every element w/ the class navlink.
                element.addEventListener('click', () => { // add click event
                    if (!element.classList.contains('active')) { // if clicked elemnt doesn't contain active,
                        navlinks.forEach(element => {
                            element.classList.remove('active'); // remove active from everything else
                        });
                        element.classList.add('active'); // then add active to the clicked element
                    }
                });
            });
        }
    </script>
    <div id="particles-js"></div>
    <nav>
        <div id="inset">
            <a onclick=setActive() class="navlink" href="../index.html#hero">Home</a>
            <a onclick=setActive() class="navlink" href="../index.html#projects">Projects</a>
            <a onclick=setActive() class="navlink" href="../index.html#competitions">Competitions</a>
            <a onclick=setActive() class="active navlink" href="../index.html#blog">Blog</a>
        </div>
    </nav>
    <div class="content">
    <h2>Swift is a strongly typed language.</h2>
    <ul>
        <li>Wtf does this mean?<ul>
                <li>It is required to state the type of each variable. For example:</li>
                <li><code>var String = "Apple"</code></li>
            </ul>
        </li>
    </ul>
    <h2>Arrays &amp; Sets</h2>
    <h3>Arrays</h3>
    <p>An array stores an ordered collection of values of the same data type.</p>
    <p>
    <pre>
var Array1 = [String]()
var Array2: [String] = []
// both create an empty array that contains strings</pre>
    </p>
    <p><strong>.count property</strong></p>
    <p>
    <pre>
var randomExample: [Double] = [1.1, 1.3, 1.42, 0.12]<br><br>
print(count.randomExample) // returns 4 Int</pre>
    </p>
    <p><strong>**<code>.append()</code>Â Method andÂ <code>+=</code>Â Operator</strong></p>
    <ul>
        <li>TheÂ <code>.append()</code>Â method can be called on an array to add an item to the end of the array.</li>
        <li>TheÂ <code>+=</code>Â addition assignment operator can be used to add the elements of another array to the
            existing array.</li>
    </ul>
    <p>
    <pre>
var gymBadges =Â ["Boulder", "Cascade"] 
gymBadges.append("Thunder")
gymBadges += ["Rainbow", "Soul"] 
// ["Boulder", "Cascade", "Thunder", "Rainbow", "Soul"]</pre>
    </p>
    <p><strong>**<code>.insert()</code>Â andÂ <code>.remove()</code>Â Methods</strong></p>
    <ul>
        <li>TheÂ <code>.insert()</code>Â method can be called on an array to add an element at a specified index.<ul>
                <li>It takes two arguments:Â <code>value</code>Â andÂ <code>at: index</code>.</li>
            </ul>
        </li>
        <li>TheÂ <code>.remove()</code>Â method can be called on an array to remove an element at a specified index.<ul>
                <li>It takes one argument:Â <code>at: index</code>.</li>
            </ul>
        </li>
    </ul>
    <p>
    <pre>var moon =Â ["ðŸŒ–", "ðŸŒ—", "ðŸŒ˜", "ðŸŒ‘"] 
moon.insert("ðŸŒ•", at: 0) // ["ðŸŒ•", "ðŸŒ–", "ðŸŒ—", "ðŸŒ˜", "ðŸŒ‘"] 
moon.remove(at: 4) // ["ðŸŒ•", "ðŸŒ–", "ðŸŒ—", "ðŸŒ˜"]</pre>
    </p>
    <p><strong><em>*Iterating Over an Array</em></strong>*</p>
    <ul>
        <li>In Swift, aÂ <code>for</code>-<code>in</code>Â loop can be used to iterate through the items of an array.</li>
        <li>This is a powerful tool for working with and manipulating a large amount of data.</li>
    </ul>
    <p>
    <pre>
var employees =Â ["Michael", "Dwight", "Jim", "Pam", "Andy"] 
for person in employees {Â Â 
    print(person)
    } 
// Prints: Michael
// Prints: Dwight
// Prints: Jim
// Prints: Pam
// Prints: Andy</pre>
    </p>
    <p><strong><em>*Swift Sets</em></strong>*</p>
    <ul>
        <li>We can use a set to store unique elements of the same data type.</li>
    </ul>
    <p>
    <pre>
var paintings: Set /* IMPORTANT */ =Â ["The Dream", "The Starry Night", "The False Mirror"]</pre>
    </p>
    <p><strong><em>*Empty Sets</em></strong>*</p>
    <ul>
        <li>An empty set is a set that contains no values inside of it.</li>
    </ul>
    <p>
    <pre>
var team =Â Set&lt;String&gt;() 
print(team)// Prints: []</pre>
    </p>
    <p><strong><em>*Populated Sets</em></strong>*</p>
    <ul>
        <li>To create a set populated with values, use theÂ <code>Set</code>Â keyword before the assignment operator.</li>
        <li>The values of the set must be contained within bracketsÂ <code>[]</code>Â and separated with
            commasÂ <code>,</code>.</li>
    </ul>
    <p>
    <pre>
var vowels: Set =Â ["a", "e", "i", "o", "u"]</pre>
    </p>
    <p><strong><em>*.insert()</em></strong>*</p>
    <p>To insert a single value into a set, appendÂ <code>.insert()</code>Â to a set and place the new value inside the
        parenthesesÂ <code>()</code>.</p>
    <p>
    <pre>var cookieJar: Set =Â ["Chocolate Chip", "Oatmeal Raisin"]
// Add aÂ new element
cookieJar.insert("Peanut Butter Chip")</pre>
    </p>
    <p><strong><em>*.remove() and .removeAll() Methods</em></strong>*</p>
    <p>To remove a single value from a set, appendÂ <code>.remove()</code>Â to a set with the value to be removed placed
        inside the parenthesesÂ <code>()</code>.</p>
    <p>To remove every single value from a set at once, appendÂ <code>.removeAll()</code>Â to a set.</p>
    <p>
    <pre>var oddNumbers: Set =Â [1, 2, 3, 5] 
// Remove an existing element
oddNumbers.remove(2) 
// Remove all elements
oddNumbers.removeAll()</pre>
    </p>
    <p><strong><em>*.contains()</em></strong>*</p>
    <p>AppendingÂ <code>.contains()</code>Â to an existing set with an item in the parenthesesÂ <code>()</code>Â will return
        aÂ <code>true</code>Â orÂ <code>false</code>Â value that states whether the item exists within the set.</p>
    <p>
    <pre>
var names: Set =Â ["Rosa", "Doug", "Waldo"] 
print(names.contains("Lola")) // Prints: false 
if names.contains("Waldo") {Â Â 
    print("There's Waldo!")
  } else {Â Â 
    print("Where's Waldo?")
}
// Prints: There's Waldo!</pre>
    </p>
    <p><strong><em>*Iterating Over a Set</em></strong>*</p>
    <p>AÂ <code>for</code>-<code>in</code>Â loop can be used to iterate over each item in a set.</p>
    <p>
    <pre>
var recipe: Set =Â ["Chocolate chips", "Eggs", "Flour", "Sugar"]
for ingredient in recipe {
Â Â print ("Include \\(ingredient) in the recipe.")
}</pre>
    </p>
    <p><strong><em>*.isEmpty Property</em></strong>*</p>
    <p>Use the built-in propertyÂ <code>.isEmpty</code>Â to check if a set has no values contained in it.</p>
    <p>
    <pre>var emptySet =Â Set&lt;String&gt;()
print(emptySet.isEmpty)Â Â 
// Prints: true 
var populatedSet: Set =Â [1, 2, 3] 
print(populatedSet.isEmpty) 
// Prints: false</pre>
    </p>
    <p><strong><em>*.count Property</em></strong>*</p>
    <p>The propertyÂ <code>.count</code>Â returns the number of elements contained within a set.</p>
    <p>
    <pre>var band: Set =Â ["Guitar", "Bass", "Drums", "Vocals"]
print("There are \\(band.count) players in the band.")
// Prints: There are 4Â players in the band.</pre>
    </p>
    <p><strong><em>*.intersection() Operation</em></strong>*</p>
    <p>TheÂ <code>.intersection()</code>Â operation populates a new set of elements with the overlapping elements of two
        sets.</p>
    <p>a intersect b</p>
    <p>
    <pre>var setA: Set =Â ["A", "B", "C", "D"]
var setB: Set =Â ["C", "D", "E", "F"] 
var setC =Â setA.intersection(setB)
print(setC)Â Â 
// Prints: ["D", "C"]</pre>
    </p>
    <p><strong><em>*.union() Operation</em></strong>*</p>
    <p>TheÂ <code>.union()</code>Â operation populates a new set by taking all the values from two sets and combining
        them.</p>
    <p>a U b</p>
    <p>
    <pre>var setA: Set =Â ["A", "B", "C", "D"]
var setB: Set =Â ["C", "D", "E", "F"]
var setC =Â setA.union(setB)print(setC) 
// Prints: ["B", "A", "D", "F", "C", "E"]</pre>
    </p>
    <p><strong><em>*.symmetricDifference() Operation</em></strong>*</p>
    <p>TheÂ <code>.symmetricDifference()</code>Â operation creates a new set with all the non-overlapping values between
        two sets.</p>
    <p>aâ€™ intersect bâ€™</p>
    <p>
    <pre>var setA: Set =Â ["A", "B", "C", "D"]
var setB: Set =Â ["C", "D", "E", "F"]
var setC =Â setA.symmetricDifference(setB)
print(setC) 
// Prints: ["B", "E", "F", "A"]</pre>
    </p>
    <p><strong><em>*.subtracting() Operation</em></strong>*</p>
    <p>TheÂ <code>.subtracting()</code>Â operation removes the values of one second set from another set and stores the
        remaining values in a new set.</p>
    <p>a</p>
    <p>
    <pre>var setA: Set =Â ["A", "B", "C", "D"]
var setB: Set =Â ["C", "D"]
var setC =Â setA.subtracting(setB)
print(setC)
// Prints: ["B", "A"]</pre>
    </p>
    <h2><strong>Functions</strong></h2>
    <ul>
        <li>A function definition consists of a function name followed by optional parameters and a return type. If no
            return type is declared, it will be Void. -&gt; Returns none. Only prints.</li>
    </ul>
    <p>
    <pre>
func washCar() -&gt; Void {
  print("Soap")
  print("Scrub")
  print("Rinse")
  print("Dry")
}</pre>
    </p>
    <ul>
        <li>The function body holds the functionâ€™s task.</li>
        <li>A function will execute only when it is called.</li>
    </ul>
    <p>
    <pre>
washCar()
// Output: Soap \\n Scrub \\n Rinse \\n Dry</pre>
    </p>
    <ul>
        <li>AÂ <code>return</code>Â keyword is used to return a value from a function.</li>
    </ul>
    <h3>Returning</h3>
    <ul>
        <li>A functionâ€™s return type is specified in the function definition followed by anÂ <code>&gt;</code>. If a
            function does not return any values, itâ€™s return type isÂ <code>Void</code>Â or the arrow and type are omitted
            entirely.</li>
        <li>AÂ <code>return</code>Â statement can be omitted if the function consists of only one expression to return.
            This
            is called anÂ <em>implicit return</em>.</li>
        <li>A parameter is a placeholder for a real value passed into a function. A parameter must be enclosed
            withinÂ <code>()</code>Â of a function definition and must have a specific type.</li>
    </ul>
    <h3>Parameters</h3>
    <ul>
        <li>An argument is a real value passed in for a parameter in the function call.</li>
        <li>A function can accept multiple parameters separated by commas.</li>
        <li>As many parameters as a function accepts, as many arguments or real values must be passed into the function
            when it is called.</li>
    </ul>
    <p>
    <pre>
func convertFracToDec(numerator: Double, denominator: Double) -&gt; Double {
  return numerator / denominator
} </pre>
    </p>
    <p>
    <pre>let decimal = convertFracToDec(numerator: 1.0, denominator: 2.0)
print(decimal) // Prints: 0.5
</pre>
    </p>
    <ul>
        <li>A function can return multiple values in the form of a tuple.</li>
    </ul>
    <h3>Parameter Types</h3>
    <ul>
        <li>Swift offers support for wide variety of parameter use cases within a function:<ul>
                <li><strong>Default Parameter</strong>: a parameter that sets a value to the parameter that will be used
                    if an
                    argument is omitted.</li>
                <li><strong>Variadic Parameter</strong>: a parameter that accepts zero or more values of the parameterâ€™s
                    type.
                </li>
                <li><strong>In-out Parameter</strong>: a parameter whose value is passed into a function and modified
                    within
                    the body.</li>
            </ul>
        </li>
    </ul>
    <p><img alt="" src="Screenshot%202022-06-24%20at%201.46.53%20PM.png" /></p>
    <h2>Structures (not Classes)</h2>
    <ul>
        <li>Structures are a means of modeling real life objects programmatically.</li>
        <li>How to create a structure using <code>struct</code> ?</li>
    </ul>
    <p>
    <pre>
struct Apple {
    var price = Double
    var sale = Bool
    init(Double: price, Bool: sale)
        price = self.price
        sale = self.sale
    func exampleMethod -&gt; String {
        print("Hello World")
    }</pre>
    </p>
    <ul>
        <li>
            <p>To model individual objects, we can create instances ofÂ <code>structs</code>Â which may have unique
                property
                values.</p>
        </li>
        <li>
            <p>We can access and edit properties using dot notation.</p>
        </li>
        <li>
            <p>If we know that most of our instances will have a specific property value, we can assign default property
                values inside the struct.</p>
        </li>
        <li>
            <p>Using theÂ <code>init()</code>Â method allows us to provide an instance with specific values for the
                structures
                given properties.</p>
        </li>
        <li>
            <p>Even without anÂ <code>init()</code>Â method, structs come with a default memberwise initialization method
                that
                can assign values to declared properties inside a struct.</p>
        </li>
        <li>
            <p>Structures can have methods that are functions accessible to their instances.</p>
        </li>
        <li>
            <p>Structures are value types, any copied struct that has its properties altered will not affect the
                original
                structure from which it was copied.</p>
        </li>
    </ul>
    <p><strong>Diff between classes and structures in Swift</strong></p>
    <ul>
        <li>Inheritance enables one class to inherit the characteristics of another class.</li>
        <li>Classes are reference types while structures are value types.</li>
    </ul>
    <h2>Classes</h2>
    <p>Also can be applied in <a href="Python%20Notes.md">Python</a></p>
    <h3>Class Inheritance</h3>
    <p>To create a class that inherits from another, we put the name of the class weâ€™re inheriting from (superclass)
        after the name of the class weâ€™re creating (subclass), like so:</p>
    <p>
    <pre>
class Subclass: Superclass {}</pre>
    </p>
    </p>
    <p>The subclass will inherit the properties and functions and literally everything from the superclass. However,
        subclasses can have special properties that are more special that superclasses do not have.</p>
    <h3>Overriding Methods</h3>
    <ul>
        <li>A subclass can provide its own custom implementation of a property or method that is inherited from a
            superclass. This is known asÂ <em>overriding</em>.<ul>
                <li>To override a method, we can redeclare it in the subclass and add theÂ <code>override</code>Â keyword
                    to let
                    the compiler know that we arenâ€™t accidentally creating a method with the same name as the one in the
                    parent
                    class.</li>
            </ul>
        </li>
    </ul>
    <p>
    <pre>
override func name(parameter) {

}</pre>
    </p>
    <ul>
        <li>A class is another means of modeling real-life objects programmatically.</li>
        <li>How to create a class using theÂ <code>class</code>Â keyword.</li>
    </ul>
    <p>
    <pre>
// Using data types:
class Student {
  var name: String
  var year: Int
  var gpa: Double
  var honors: Bool
  init()
}</pre>
    </p>
    <p>
    <pre>
// Using default property values:
class Student {
  var name = ""
  var year = 0
  var gpa = 0.0
  var honors = false
}
    </pre>
    </p>
    <ul>
        <li>Using theÂ <code>init()</code>Â method allows us to provide an instance with specific values right off-the-bat
            during the creation of an instance.</li>
    </ul>
    <p>
    <pre>
class Fruit {
  var hasSeeds = true
  var color: String
  init(color: String) {
    self.color = color
  }
}
let apple = Fruit(color: "red")
</pre>
    </p>
    <ul>
        <li>
            <p>A class can inherit another classâ€™s properties and methods.</p>
        </li>
        <li>
            <p>When using inheritance, the subclass can use theÂ <code>override</code>Â keyword to redeclare a method with
                the
                same name.</p>
        </li>
        <li>
            <p>Classes are reference types, any copied class that has its properties altered will affect the original
                class
                from which it was copied.</p>
        </li>
    </ul>
    <h4>In Swift, a <strong><code>struct</code></strong> is a value type that can hold a collection of related
        properties and methods. A <strong><code>class</code></strong> is a reference type that can also hold a
        collection
        of related properties and methods. An <strong><code>object</code></strong> is an instance of a class, and it
        contains the actual data and behavior of the class.</h4>
    <ul>
        <li>
            <p>The main difference between <strong><code>struct</code></strong> and <strong><code>class</code></strong>
                is
                that <strong><code>struct</code></strong> is a value type and <strong><code>class</code></strong> is a
                reference type. This means that when a <strong><code>struct</code></strong> is assigned to a variable or
                passed as an argument to a function, a copy of the <strong><code>struct</code></strong> is created and
                used,
                whereas a <strong><code>class</code></strong> is passed by reference, so the original
                <strong><code>class</code></strong> is used.
            </p>
        </li>
        <li>
            <p>In general, <strong><code>struct</code></strong> is used for simple data types that do not require
                inheritance or complex behavior, while <strong><code>class</code></strong> is used for more complex data
                types
                that may need to inherit from other classes or be part of a hierarchy of objects.</p>
        </li>
        <li>
            <p>Here is an example of how <strong><code>struct</code></strong>, <strong><code>class</code></strong>, and
                <strong><code>object</code></strong> are used in Swift:
            </p>
        </li>
    </ul>
    <p>
    <pre>
struct Point {
    var x: Double
    var y: Double
}

class Shape {
    var color: String
    
    init(color: String) {
        self.color = color
    }
    
    func draw() {
        print("Drawing a shape with color: \(color)")
    }
}

let point1 = Point(x: 1.0, y: 2.0)
var point2 = point1
point2.x = 3.0
print(point1.x) // 1.0
print(point2.x) // 3.0

let shape1 = Shape(color: "red")
var shape2 = shape1
shape2.color = "blue"
print(shape1.color) // red
print(shape2.color) // blue</pre>
    </p>
    <p>In this example, the <strong><code>Point</code></strong> struct is a value type that holds the coordinates of a
        point. The <strong><code>Shape</code></strong> class is a reference type that holds the color of a shape and has
        a
        <strong><code>draw</code></strong> method. When a <strong><code>Point</code></strong> instance is assigned to
        another variable, a copy of the <strong><code>Point</code></strong> is created and used, so changing the value
        of
        the copied <strong><code>Point</code></strong> does not affect the original <strong><code>Point</code></strong>.
        When a <strong><code>Shape</code></strong> instance is assigned to another variable, a reference to the
        <strong><code>Shape</code></strong> is used, so changing the value of the copied
        <strong><code>Shape</code></strong> also changes the value of the original <strong><code>Shape</code></strong>.
    </p>
    <h3>In reference to my previous question, is an object also an instance of a struct?</h3>
    <p>In Swift, an <strong><code>object</code></strong> is an instance of a <strong><code>class</code></strong>, not a
        <strong><code>struct</code></strong>. A <strong><code>struct</code></strong> is a value type, whereas a
        <strong><code>class</code></strong> is a reference type, so the two are not interchangeable.
    </p>
    <p>An instance of a <strong><code>struct</code></strong> is created using the struct's name and the initializer
        syntax, for example:</p>
    <p>
    <pre>
letÂ pointÂ = Point(x:Â 1.0, y:Â 2.0)</pre>
    </p>
    <p>An instance of a <strong><code>class</code></strong> is created using the <strong><code>class</code></strong>
        keyword and the initializer syntax, for example:</p>
    <p>
    <pre>
letÂ shapeÂ = Shape(color:Â "red")</pre>
    </p>
    <p>In both cases, the resulting value is an instance of the specified type. However, the instance of a
        <strong><code>struct</code></strong> is a value type, while the instance of a
        <strong><code>class</code></strong>
        is a reference type. This means that the <strong><code>struct</code></strong> instance is a copy of the original
        <strong><code>struct</code></strong>, while the <strong><code>class</code></strong> instance is a reference to
        the
        original <strong><code>class</code></strong>.
    </p>
    <h3>Explain what are mutating functions in the context of Swift</h3>
    <ul>
        <li>
            <p>In the context of programming languages, a mutating function is a function that can modify the state of
                an
                object in place, rather than creating and returning a new object. In other words, a mutating function
                can
                change the value of a variable or object directly, without the need to create a copy of the object.</p>
        </li>
        <li>
            <p>In Swift, a mutating function is a function that is marked with the
                <strong><code>mutating</code></strong>
                keyword. This keyword indicates that the function can modify the properties of the object it belongs to.
                For
                example, the following code defines a <strong><code>Person</code></strong> struct with a
                <strong><code>name</code></strong> property and a <strong><code>changeName</code></strong> mutating
                function
                that can be used to change the value of the <strong><code>name</code></strong> property:
            </p>
        </li>
    </ul>
    <p>
    <!-- <pre>
structÂ PersonÂ {Â varÂ name:Â StringmutatingÂ funcchangeName(newName:Â String) { nameÂ =Â newName } }</pre> -->
    </p>
    <p>In Swift, mutating functions are useful for modifying the state of an object in place, without the need to create
        a new object. However, they can also cause confusion and make code harder to reason about, so they should be
        used
        with care.</p>
    </div>
</body>

</html>